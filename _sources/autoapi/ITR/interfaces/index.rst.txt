:py:mod:`ITR.interfaces`
========================

.. py:module:: ITR.interfaces


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   ITR.interfaces.SortableEnum
   ITR.interfaces.EScope
   ITR.interfaces.ETimeFrames
   ITR.interfaces.ECarbonBudgetScenario
   ITR.interfaces.EScoreResultType
   ITR.interfaces.AggregationContribution
   ITR.interfaces.Aggregation
   ITR.interfaces.ScoreAggregation
   ITR.interfaces.ScoreAggregationScopes
   ITR.interfaces.ScoreAggregations
   ITR.interfaces.PortfolioCompany
   ITR.interfaces.UProjection
   ITR.interfaces.IProjection
   ITR.interfaces.IBenchmark
   ITR.interfaces.IBenchmarks
   ITR.interfaces.IProductionBenchmarkScopes
   ITR.interfaces.IEIBenchmarkScopes
   ITR.interfaces.ICompanyEIProjection
   ITR.interfaces.ICompanyEIProjections
   ITR.interfaces.DF_ICompanyEIProjections
   ITR.interfaces.ICompanyEIProjectionsScopes
   ITR.interfaces.IProductionRealization
   ITR.interfaces.IEmissionRealization
   ITR.interfaces.IHistoricEmissionsScopes
   ITR.interfaces.IEIRealization
   ITR.interfaces.IHistoricEIScopes
   ITR.interfaces.IHistoricData
   ITR.interfaces.ITargetData
   ITR.interfaces.ICompanyData
   ITR.interfaces.ICompanyAggregates




Attributes
~~~~~~~~~~

.. autoapisummary::

   ITR.interfaces.logger


.. py:data:: logger

   

.. py:class:: SortableEnum


   Bases: :py:obj:`enum.Enum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. py:method:: __str__()

      Return str(self).


   .. py:method:: __ge__(other)

      Return self>=value.


   .. py:method:: __gt__(other)

      Return self>value.


   .. py:method:: __le__(other)

      Return self<=value.


   .. py:method:: __lt__(other)

      Return self<value.



.. py:class:: EScope


   Bases: :py:obj:`SortableEnum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. py:attribute:: S1
      :value: 'S1'

      

   .. py:attribute:: S2
      :value: 'S2'

      

   .. py:attribute:: S3
      :value: 'S3'

      

   .. py:attribute:: S1S2
      :value: 'S1+S2'

      

   .. py:attribute:: S1S2S3
      :value: 'S1+S2+S3'

      

   .. py:attribute:: AnyScope
      :value: 'AnyScope'

      

   .. py:method:: __str__()

      Return str(self).


   .. py:method:: __repr__()

      Return repr(self).


   .. py:method:: get_scopes() -> List[str]
      :classmethod:

      Get a list of all scopes.
      :return: A list of EScope string values


   .. py:method:: get_result_scopes() -> List[EScope]
      :classmethod:

      Get a list of scopes that should be calculated if the user leaves it open.

      :return: A list of EScope objects



.. py:class:: ETimeFrames


   Bases: :py:obj:`SortableEnum`

   TODO: add support for multiple timeframes. Long currently corresponds to 2050.

   .. py:attribute:: SHORT
      :value: 'short'

      

   .. py:attribute:: MID
      :value: 'mid'

      

   .. py:attribute:: LONG
      :value: 'long'

      


.. py:class:: ECarbonBudgetScenario


   Bases: :py:obj:`enum.Enum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. py:attribute:: P25
      :value: '25 percentile'

      

   .. py:attribute:: P75
      :value: '75 percentile'

      

   .. py:attribute:: MEAN
      :value: 'Average'

      


.. py:class:: EScoreResultType


   Bases: :py:obj:`enum.Enum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. py:attribute:: DEFAULT
      :value: 'Default'

      

   .. py:attribute:: TRAJECTORY_ONLY
      :value: 'Trajectory only'

      

   .. py:attribute:: TARGET_ONLY
      :value: 'Target only'

      

   .. py:attribute:: COMPLETE
      :value: 'Complete'

      

   .. py:method:: __str__()

      Return str(self).


   .. py:method:: __repr__()

      Return repr(self).


   .. py:method:: get_result_types() -> List[str]
      :classmethod:

      Get a list of all result types, ordered by priority (first << last priority).
      :return: A list of the EScoreResultType values



.. py:class:: AggregationContribution


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: company_name
      :type: str

      

   .. py:attribute:: company_id
      :type: str

      

   .. py:attribute:: temperature_score
      :type: quantity('delta_degC')

      

   .. py:attribute:: contribution_relative
      :type: Optional[quantity('percent')]

      

   .. py:attribute:: contribution
      :type: Optional[quantity('delta_degC')]

      

   .. py:method:: __getitem__(item)



.. py:class:: Aggregation


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: score
      :type: quantity('delta_degC')

      

   .. py:attribute:: proportion
      :type: float

      

   .. py:attribute:: contributions
      :type: List[AggregationContribution]

      

   .. py:method:: __getitem__(item)



.. py:class:: ScoreAggregation


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: all
      :type: Aggregation

      

   .. py:attribute:: influence_percentage
      :type: quantity('percent')

      

   .. py:attribute:: grouped
      :type: Dict[str, Aggregation]

      

   .. py:method:: __getitem__(item)



.. py:class:: ScoreAggregationScopes


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: S1
      :type: Optional[ScoreAggregation]

      

   .. py:attribute:: S2
      :type: Optional[ScoreAggregation]

      

   .. py:attribute:: S1S2
      :type: Optional[ScoreAggregation]

      

   .. py:attribute:: S3
      :type: Optional[ScoreAggregation]

      

   .. py:attribute:: S1S2S3
      :type: Optional[ScoreAggregation]

      

   .. py:method:: __getitem__(item)



.. py:class:: ScoreAggregations


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: short
      :type: Optional[ScoreAggregationScopes]

      

   .. py:attribute:: mid
      :type: Optional[ScoreAggregationScopes]

      

   .. py:attribute:: long
      :type: Optional[ScoreAggregationScopes]

      

   .. py:method:: __getitem__(item)



.. py:class:: PortfolioCompany


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: company_name
      :type: str

      

   .. py:attribute:: company_id
      :type: str

      

   .. py:attribute:: company_isin
      :type: Optional[str]

      

   .. py:attribute:: investment_value
      :type: ITR.data.osc_units.MonetaryQuantity

      

   .. py:attribute:: user_fields
      :type: Optional[dict]

      


.. py:class:: UProjection


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: year
      :type: int

      

   .. py:attribute:: value
      :type: float

      


.. py:class:: IProjection


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: year
      :type: int

      

   .. py:attribute:: value
      :type: ITR.data.osc_units.BenchmarkQuantity

      


.. py:class:: IBenchmark(benchmark_metric, projections_nounits=None, projections=None, base_year_production=None, *args, **kwargs)


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: sector
      :type: str

      

   .. py:attribute:: region
      :type: str

      

   .. py:attribute:: benchmark_metric
      :type: ITR.data.osc_units.BenchmarkMetric

      

   .. py:attribute:: projections_nounits
      :type: Optional[List[UProjection]]

      

   .. py:attribute:: projections
      :type: Optional[List[IProjection]]

      

   .. py:attribute:: base_year_production
      :type: Optional[ITR.data.osc_units.ProductionQuantity]

      

   .. py:method:: __getitem__(item)



.. py:class:: IBenchmarks


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: benchmarks
      :type: List[IBenchmark]

      

   .. py:attribute:: production_centric
      :value: False

      

   .. py:method:: __getitem__(item)



.. py:class:: IProductionBenchmarkScopes


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: AnyScope
      :type: Optional[IBenchmarks]

      

   .. py:attribute:: S1
      :type: Optional[IBenchmarks]

      

   .. py:attribute:: S2
      :type: Optional[IBenchmarks]

      

   .. py:attribute:: S1S2
      :type: Optional[IBenchmarks]

      

   .. py:attribute:: S3
      :type: Optional[IBenchmarks]

      

   .. py:attribute:: S1S2S3
      :type: Optional[IBenchmarks]

      

   .. py:method:: __getitem__(item)



.. py:class:: IEIBenchmarkScopes


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: S1
      :type: Optional[IBenchmarks]

      

   .. py:attribute:: S2
      :type: Optional[IBenchmarks]

      

   .. py:attribute:: S1S2
      :type: Optional[IBenchmarks]

      

   .. py:attribute:: S3
      :type: Optional[IBenchmarks]

      

   .. py:attribute:: S1S2S3
      :type: Optional[IBenchmarks]

      

   .. py:attribute:: benchmark_temperature
      :type: quantity('delta_degC')

      

   .. py:attribute:: benchmark_global_budget
      :type: quantity('Gt CO2')

      

   .. py:attribute:: is_AFOLU_included
      :type: bool

      

   .. py:method:: __getitem__(item)



.. py:class:: ICompanyEIProjection


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: year
      :type: int

      

   .. py:attribute:: value
      :type: Optional[ITR.data.osc_units.EI_Quantity]

      

   .. py:method:: __getitem__(item)


   .. py:method:: __eq__(o)


   .. py:method:: add(o)


   .. py:method:: min(o)



.. py:class:: ICompanyEIProjections


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: ei_metric
      :type: ITR.data.osc_units.EI_Metric

      

   .. py:attribute:: projections
      :type: List[ICompanyEIProjection]

      

   .. py:method:: __getitem__(item)


   .. py:method:: __str__()



.. py:class:: DF_ICompanyEIProjections(icompany_ei_projections=None, *args, **kwargs)


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:class:: Config


      .. py:attribute:: arbitrary_types_allowed
         :value: True

         


   .. py:attribute:: ei_metric
      :type: Optional[ITR.data.osc_units.EI_Metric]

      

   .. py:attribute:: projections
      :type: pandas.Series

      

   .. py:method:: allow_projections(v)



.. py:class:: ICompanyEIProjectionsScopes(*args, **kwargs)


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: S1
      :type: Optional[DF_CompanyEIProjections]

      

   .. py:attribute:: S2
      :type: Optional[DF_CompanyEIProjections]

      

   .. py:attribute:: S1S2
      :type: Optional[DF_CompanyEIProjections]

      

   .. py:attribute:: S3
      :type: Optional[DF_CompanyEIProjections]

      

   .. py:attribute:: S1S2S3
      :type: Optional[DF_CompanyEIProjections]

      

   .. py:method:: __getitem__(item)


   .. py:method:: __str__()



.. py:class:: IProductionRealization


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: year
      :type: int

      

   .. py:attribute:: value
      :type: Optional[ITR.data.osc_units.ProductionQuantity]

      


.. py:class:: IEmissionRealization


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: year
      :type: int

      

   .. py:attribute:: value
      :type: Optional[ITR.data.osc_units.EmissionsQuantity]

      

   .. py:method:: __getitem__(item)


   .. py:method:: __eq__(o)


   .. py:method:: add(o)



.. py:class:: IHistoricEmissionsScopes


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: S1
      :type: List[IEmissionRealization]

      

   .. py:attribute:: S2
      :type: List[IEmissionRealization]

      

   .. py:attribute:: S1S2
      :type: List[IEmissionRealization]

      

   .. py:attribute:: S3
      :type: List[IEmissionRealization]

      

   .. py:attribute:: S1S2S3
      :type: List[IEmissionRealization]

      

   .. py:method:: __getitem__(item)


   .. py:method:: __str__()



.. py:class:: IEIRealization


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: year
      :type: int

      

   .. py:attribute:: value
      :type: Optional[ITR.data.osc_units.EI_Quantity]

      

   .. py:method:: __getitem__(item)


   .. py:method:: __eq__(o)


   .. py:method:: add(o)



.. py:class:: IHistoricEIScopes


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: S1
      :type: List[IEIRealization]

      

   .. py:attribute:: S2
      :type: List[IEIRealization]

      

   .. py:attribute:: S1S2
      :type: List[IEIRealization]

      

   .. py:attribute:: S3
      :type: List[IEIRealization]

      

   .. py:attribute:: S1S2S3
      :type: List[IEIRealization]

      

   .. py:method:: __getitem__(item)


   .. py:method:: __str__()



.. py:class:: IHistoricData


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: productions
      :type: Optional[List[IProductionRealization]]

      

   .. py:attribute:: emissions
      :type: Optional[IHistoricEmissionsScopes]

      

   .. py:attribute:: emissions_intensities
      :type: Optional[IHistoricEIScopes]

      


.. py:class:: ITargetData


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: netzero_year
      :type: Optional[int]

      

   .. py:attribute:: target_type
      :type: Union[Literal[intensity], Literal[absolute], Literal[Intensity], Literal[Absolute]]

      

   .. py:attribute:: target_scope
      :type: EScope

      

   .. py:attribute:: target_start_year
      :type: Optional[int]

      

   .. py:attribute:: target_base_year
      :type: int

      

   .. py:attribute:: target_end_year
      :type: int

      

   .. py:attribute:: target_base_year_qty
      :type: float

      

   .. py:attribute:: target_base_year_err
      :type: Optional[float]

      

   .. py:attribute:: target_base_year_unit
      :type: str

      

   .. py:attribute:: target_reduction_pct
      :type: float

      

   .. py:method:: start_end_base_order(v)



.. py:class:: ICompanyData(emissions_metric=None, production_metric=None, base_year_production=None, ghg_s1s2=None, ghg_s3=None, target_data=None, historic_data=None, *args, **kwargs)


   Bases: :py:obj:`pydantic.BaseModel`

   .. py:attribute:: company_name
      :type: str

      

   .. py:attribute:: company_id
      :type: str

      

   .. py:attribute:: sector
      :type: str

      

   .. py:attribute:: region
      :type: str

      

   .. py:attribute:: target_probability
      :type: float

      

   .. py:attribute:: target_data
      :type: Optional[List[ITargetData]]

      

   .. py:attribute:: historic_data
      :type: Optional[IHistoricData]

      

   .. py:attribute:: country
      :type: Optional[str]

      

   .. py:attribute:: emissions_metric
      :type: Optional[ITR.data.osc_units.EmissionsMetric]

      

   .. py:attribute:: production_metric
      :type: Optional[ITR.data.osc_units.ProductionMetric]

      

   .. py:attribute:: base_year_production
      :type: Optional[ITR.data.osc_units.ProductionQuantity]

      

   .. py:attribute:: ghg_s1s2
      :type: Optional[ITR.data.osc_units.EmissionsQuantity]

      

   .. py:attribute:: ghg_s3
      :type: Optional[ITR.data.osc_units.EmissionsQuantity]

      

   .. py:attribute:: industry_level_1
      :type: Optional[str]

      

   .. py:attribute:: industry_level_2
      :type: Optional[str]

      

   .. py:attribute:: industry_level_3
      :type: Optional[str]

      

   .. py:attribute:: industry_level_4
      :type: Optional[str]

      

   .. py:attribute:: company_revenue
      :type: Optional[ITR.data.osc_units.MonetaryQuantity]

      

   .. py:attribute:: company_market_cap
      :type: Optional[ITR.data.osc_units.MonetaryQuantity]

      

   .. py:attribute:: company_enterprise_value
      :type: Optional[ITR.data.osc_units.MonetaryQuantity]

      

   .. py:attribute:: company_ev_plus_cash
      :type: Optional[ITR.data.osc_units.MonetaryQuantity]

      

   .. py:attribute:: company_total_assets
      :type: Optional[ITR.data.osc_units.MonetaryQuantity]

      

   .. py:attribute:: company_cash_equivalents
      :type: Optional[ITR.data.osc_units.MonetaryQuantity]

      

   .. py:attribute:: projected_targets
      :type: Optional[ICompanyEIProjectionsScopes]

      

   .. py:attribute:: projected_intensities
      :type: Optional[ICompanyEIProjectionsScopes]

      

   .. py:method:: _sector_to_production_units(sector, region='Global')


   .. py:method:: _get_base_realization_from_historic(realized_values: List[pydantic.BaseModel], metric, base_year=None)


   .. py:method:: _normalize_historic_data(historic_data: IHistoricData, production_metric: ITR.data.osc_units.ProductionMetric, emissions_metric: ITR.data.osc_units.EmissionsMetric) -> IHistoricData



.. py:class:: ICompanyAggregates(emissions_metric=None, production_metric=None, base_year_production=None, ghg_s1s2=None, ghg_s3=None, target_data=None, historic_data=None, *args, **kwargs)


   Bases: :py:obj:`ICompanyData`

   .. py:attribute:: cumulative_budget
      :type: Optional[ITR.data.osc_units.EmissionsQuantity]

      

   .. py:attribute:: cumulative_scaled_budget
      :type: Optional[ITR.data.osc_units.EmissionsQuantity]

      

   .. py:attribute:: cumulative_trajectory
      :type: Optional[ITR.data.osc_units.EmissionsQuantity]

      

   .. py:attribute:: cumulative_target
      :type: Optional[ITR.data.osc_units.EmissionsQuantity]

      

   .. py:attribute:: benchmark_temperature
      :type: Optional[quantity('delta_degC')]

      

   .. py:attribute:: benchmark_global_budget
      :type: Optional[ITR.data.osc_units.EmissionsQuantity]

      

   .. py:attribute:: scope
      :type: Optional[EScope]

      

   .. py:attribute:: trajectory_exceedance_year
      :type: Optional[int]

      

   .. py:attribute:: target_exceedance_year
      :type: Optional[int]

      

   .. py:method:: allow_NA(v)


   .. py:method:: from_ICompanyData(super_instance, scope_company_data)
      :classmethod:

      Fast way to add instance variables to a pre-validated SUPER_INSTANCE
      SCOPE_COMPANY_DATA is the dictionary of the new values we want to add...for this one company



